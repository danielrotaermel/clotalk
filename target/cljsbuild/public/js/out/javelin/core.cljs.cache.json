["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Array",["^ ","~$prototype",["^ ","~$slice",["^ ","~$call",["^ "]]]]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$javelin.core","~:imports",null,"~:requires",["^ ","~$garray","~$goog.array","^@","^@","~$gobj","~$goog.object","^B","^B"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$->Cell",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","~:line",104,"~:column",10,"~:end-line",104,"~:end-column",14,"~:protocols",["^:",["~$cljs.core/IWatchable","~$cljs.core/IReset","~$cljs.core/ISwap","~$cljs.core/IMeta","~$cljs.core/IDeref","~$cljs.core/IPrintWithWriter","~$cljs.core/IWithMeta"]],"~:skip-protocol-flag",["^:",["^O","^P","^Q","^R","^S","^T","^U"]],"~:factory","~:positional","~:arglists",["~#list",["~$quote",["^Z",[["~$meta","~$state","~$rank","~$prev","~$sources","~$sinks","~$thunk","~$watches","~$update","~$constant","~$numwatches"]]]]]],"^N",["^:",["^O","^P","^Q","^R","^S","^T","^U"]],"^;","~$javelin.core/->Cell","~:variadic",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",14,"~:method-params",["^Z",[["^10","^11","^12","^13","^14","^15","^16","^17","^18","^19","^1:"]]],"~:protocol-impl",null,"~:arglists-meta",["^Z",[null,null]],"^K",1,"^W","^X","^J",104,"^L",104,"~:max-fixed-arity",11,"~:fn-var",true,"^Y",["^Z",["^[",["^Z",[["^10","^11","^12","^13","^14","^15","^16","^17","^18","^19","^1:"]]]]],"^V",["^:",["^O","^P","^Q","^R","^S","^T","^U"]]],"~$next-rank",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",38,"^K",8,"^L",38,"^M",17,"~:private",true,"^Y",["^Z",["^[",["^Z",[[]]]]]],"^1C",true,"^;","~$javelin.core/next-rank","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",17,"^1=",["^Z",[[]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",38,"^L",38,"^1@",0,"^1A",true,"^Y",["^Z",["^[",["^Z",[[]]]]]],"~$input?",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",160,"^K",7,"^L",160,"^M",13,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"^;","~$javelin.core/input?","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",13,"^1=",["^Z",[["~$c"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",160,"^L",160,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"~$cell",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",201,"^K",7,"^L",201,"^M",11,"^Y",["^Z",["^[",["^Z",[["~$x"],["~$x","~$&",["^ ","~:keys",["^10"]]]]]]],"~:doc","Returns a new input cell containing value x. The :meta option can be used\n  to create the cell with the given metadata map.","~:top-fn",["^ ","^1<",true,"^1@",1,"^1=",["^Z",[["~$x"]]],"^Y",["^Z",[["~$x"],["~$x","~$&",["^ ","^1H",["^10"]]]]],"^1?",["^Z",[null,null]]]],"^;","~$javelin.core/cell","^1<",true,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",11,"^1J",["^ ","^1<",true,"^1@",1,"^1=",["^Z",[["~$x"]]],"^Y",["^Z",[["~$x"],["~$x","~$&",["^ ","^1H",["^10"]]]]],"^1?",["^Z",[null,null]]],"^1=",["^Z",[["~$x"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",201,"^L",201,"^1@",1,"^1A",true,"^Y",["^Z",[["~$x"],["~$x","~$&",["^ ","^1H",["^10"]]]]],"^1I","Returns a new input cell containing value x. The :meta option can be used\n  to create the cell with the given metadata map."],"~$cell?",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",145,"^K",7,"^L",145,"^M",12,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]],"^1I","Returns c if c is a Cell, nil otherwise."],"^;","~$javelin.core/cell?","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",12,"^1=",["^Z",[["~$c"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",145,"^L",145,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]],"^1I","Returns c if c is a Cell, nil otherwise."],"~$destroy-cell!",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",47,"^K",7,"^L",47,"^M",20,"^Y",["^Z",["^[",["^Z",[["~$this"],["^1O","~$keep-watches?"]]]]],"^1I","Unlinks this Cell from the cell graph and resets all internal state. Watches\n  are preserved when keep-watches? is true, otherwise they are all removed.","^1J",["^ ","^1<",false,"^1@",2,"^1=",["^Z",[["^1O"],["^1O","^1P"]]],"^Y",["^Z",[["^1O"],["^1O","^1P"]]],"^1?",["^Z",[null,null]]]],"^;","~$javelin.core/destroy-cell!","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",20,"^1J",["^ ","^1<",false,"^1@",2,"^1=",["^Z",[["^1O"],["^1O","^1P"]]],"^Y",["^Z",[["^1O"],["^1O","^1P"]]],"^1?",["^Z",[null,null]]],"^1=",["^Z",[["^1O"],["^1O","^1P"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",47,"^L",47,"^1@",2,"^1A",true,"^Y",["^Z",[["^1O"],["^1O","^1P"]]],"^1I","Unlinks this Cell from the cell graph and resets all internal state. Watches\n  are preserved when keep-watches? is true, otherwise they are all removed."],"~$last-rank",["^ ","^;","~$javelin.core/last-rank","^I","target/cljsbuild/public/js/out/javelin/core.cljs","^J",19,"^K",1,"^L",19,"^M",25,"^1C",true,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",19,"^K",16,"^L",19,"^M",25,"^1C",true],"~:tag","~$any"],"~$lift",["^ ","^;","~$javelin.core/lift","^I","target/cljsbuild/public/js/out/javelin/core.cljs","^J",207,"^K",1,"^L",207,"^M",23,"~:deprecated",true,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",207,"^K",19,"^L",207,"^M",23,"^1X",true],"^1I","This function is deprecated, please use #'javelin.core/formula instead."],"~$lens?",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",155,"^K",7,"^L",155,"^M",12,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"^;","~$javelin.core/lens?","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",12,"^1=",["^Z",[["~$c"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",155,"^L",155,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"~$set-formula!",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",87,"^K",7,"^L",87,"^M",19,"^Y",["^Z",["^[",["^Z",[["^1O"],["^1O","~$f"],["^1O","~$f","^14"],["^1O","~$f","^14","~$updatefn"]]]]],"^1I","Given a Cell and optional formula function f and the cells f depends on,\n  sources, updates the formula for this cell in place. If f and/or sources\n  is not spcified they are set to nil.","^1J",["^ ","^1<",false,"^1@",4,"^1=",["^Z",[["^1O"],["^1O","~$f"],["^1O","~$f","^14"],["^1O","~$f","^14","^20"]]],"^Y",["^Z",[["^1O"],["^1O","~$f"],["^1O","~$f","^14"],["^1O","~$f","^14","^20"]]],"^1?",["^Z",[null,null,null,null]]]],"^;","~$javelin.core/set-formula!","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",19,"^1J",["^ ","^1<",false,"^1@",4,"^1=",["^Z",[["^1O"],["^1O","~$f"],["^1O","~$f","^14"],["^1O","~$f","^14","^20"]]],"^Y",["^Z",[["^1O"],["^1O","~$f"],["^1O","~$f","^14"],["^1O","~$f","^14","^20"]]],"^1?",["^Z",[null,null,null,null]]],"^1=",["^Z",[["^1O"],["^1O","~$f"],["^1O","~$f","^14"],["^1O","~$f","^14","^20"]]],"^1>",null,"^1?",["^Z",[null,null,null,null]],"^K",1,"^J",87,"^L",87,"^1@",4,"^1A",true,"^Y",["^Z",[["^1O"],["^1O","~$f"],["^1O","~$f","^14"],["^1O","~$f","^14","^20"]]],"^1I","Given a Cell and optional formula function f and the cells f depends on,\n  sources, updates the formula for this cell in place. If f and/or sources\n  is not spcified they are set to nil."],"~$constant?",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",165,"^K",7,"^L",165,"^M",16,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"^;","~$javelin.core/constant?","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",16,"^1=",["^Z",[["~$c"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",165,"^L",165,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"~$add-sync!",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",41,"^K",8,"^L",41,"^M",17,"^1C",true,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"^1C",true,"^;","~$javelin.core/add-sync!","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",17,"^1=",["^Z",[["~$c"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",41,"^L",41,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"~$cmp-rank",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",39,"^K",8,"^L",39,"^M",16,"^1C",true,"^Y",["^Z",["^[",["^Z",[["~$a","~$b"]]]]]],"^1C",true,"^;","~$javelin.core/cmp-rank","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",16,"^1=",["^Z",[["~$a","~$b"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",39,"^L",39,"^1@",2,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$a","~$b"]]]]]],"~$cell-doseq*",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",266,"^K",7,"^L",266,"^M",18,"^Y",["^Z",["^[",["^Z",[["~$c","~$f"]]]]],"^1I","Given a function f and a cell c that contains a seqable collection of items,\n  calls f for side effects once for each item in c, passing one argument: a\n  formula cell equivalent to (cell= (nth c i)) for the ith item in c. Whenever\n  c grows beyond its previous maximum size f is called as above for each item\n  beyond the maximum size. Nothing happens when c shrinks.\n\n  See also: the javelin.core/cell-doseq macro.\n\n  Consider:\n\n      (def things (cell [:a :b :c]))\n      (cell-doseq*\n        things\n        (fn doit [x]\n          (prn :creating @x)\n          (add-watch x nil #(prn :updating %3 %4))))\n\n      ;; the following is printed:\n\n      :creating :a\n      :creating :b\n      :creating :c\n\n  Shrink things by removing the last item:\n\n      (swap! things pop)\n\n      ;; the following is printed (because the 3rd item in things is now nil,\n      ;; since things only contains 2 items) -- note that the doit function is\n      ;; not called (or we would see a :creating message):\n\n      :updating :c nil\n\n  Grow things such that it is one item larger than it ever was:\n\n      (swap! things into [:u :v])\n\n      ;; the following is printed (because things now has 4 items, so the 3rd\n      ;; item is now :u and the max size increases by one with the new item :v):\n\n      :updating nil :u\n      :creating :v\n\n  A weird imagination is most useful to gain full advantage of all the features."],"^;","~$javelin.core/cell-doseq*","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",18,"^1=",["^Z",[["~$c","~$f"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",266,"^L",266,"^1@",2,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c","~$f"]]]]],"^1I","Given a function f and a cell c that contains a seqable collection of items,\n  calls f for side effects once for each item in c, passing one argument: a\n  formula cell equivalent to (cell= (nth c i)) for the ith item in c. Whenever\n  c grows beyond its previous maximum size f is called as above for each item\n  beyond the maximum size. Nothing happens when c shrinks.\n\n  See also: the javelin.core/cell-doseq macro.\n\n  Consider:\n\n      (def things (cell [:a :b :c]))\n      (cell-doseq*\n        things\n        (fn doit [x]\n          (prn :creating @x)\n          (add-watch x nil #(prn :updating %3 %4))))\n\n      ;; the following is printed:\n\n      :creating :a\n      :creating :b\n      :creating :c\n\n  Shrink things by removing the last item:\n\n      (swap! things pop)\n\n      ;; the following is printed (because the 3rd item in things is now nil,\n      ;; since things only contains 2 items) -- note that the doit function is\n      ;; not called (or we would see a :creating message):\n\n      :updating :c nil\n\n  Grow things such that it is one item larger than it ever was:\n\n      (swap! things into [:u :v])\n\n      ;; the following is printed (because things now has 4 items, so the 3rd\n      ;; item is now :u and the max size increases by one with the new item :v):\n\n      :updating nil :u\n      :creating :v\n\n  A weird imagination is most useful to gain full advantage of all the features."],"~$*tx*",["^ ","^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",18,"^K",26,"^L",18,"^M",30,"~:dynamic",true,"^1C",true],"^1C",true,"^;","~$javelin.core/*tx*","^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",30,"^K",1,"^2;",true,"^J",18,"^L",18,"^1T","~$clj-nil"],"~$deref*",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",33,"^K",7,"^L",33,"^M",13,"^Y",["^Z",["^[",["^Z",[["~$x"]]]]],"^1I","If x is a Cell dereferences x and returns the value, otherwise returns x."],"^;","~$javelin.core/deref*","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",13,"^1=",["^Z",[["~$x"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",33,"^L",33,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$x"]]]]],"^1I","If x is a Cell dereferences x and returns the value, otherwise returns x."],"~$propagate!",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",43,"^K",8,"^L",43,"^M",18,"^1C",true,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"^1C",true,"^;","~$javelin.core/propagate!","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",18,"^1=",["^Z",[["~$c"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",43,"^L",43,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"~$set-formula!*",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",64,"^K",8,"^L",64,"^M",21,"^1C",true,"^Y",["^Z",["^[",["^Z",[["^1O","~$f","^14","^20"]]]]]],"^1C",true,"^;","~$javelin.core/set-formula!*","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",21,"^1=",["^Z",[["^1O","~$f","^14","^20"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",64,"^L",64,"^1@",4,"^1A",true,"^Y",["^Z",["^[",["^Z",[["^1O","~$f","^14","^20"]]]]]],"~$set-cell!",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",170,"^K",7,"^L",170,"^M",16,"^Y",["^Z",["^[",["^Z",[["~$c","~$x"]]]]],"^1I","Converts c to an input cell in place, setting its contents to x. It's okay\n  if c was already an input cell. Changes will be propagated to any cells that\n  depend on c."],"^;","~$javelin.core/set-cell!","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",16,"^1=",["^Z",[["~$c","~$x"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",170,"^L",170,"^1@",2,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c","~$x"]]]]],"^1I","Converts c to an input cell in place, setting its contents to x. It's okay\n  if c was already an input cell. Changes will be propagated to any cells that\n  depend on c."],"~$lens",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",195,"^K",7,"^L",195,"^M",11,"^Y",["^Z",["^[",["^Z",[["~$c","~$f"]]]]],"^1I","Returns a new lens whose value is the same as c's with update function f.\n  This is equivalent to ((formula identity f) c)."],"^;","~$javelin.core/lens","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",11,"^1=",["^Z",[["~$c","~$f"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",195,"^L",195,"^1@",2,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c","~$f"]]]]],"^1I","Returns a new lens whose value is the same as c's with update function f.\n  This is equivalent to ((formula identity f) c)."],"~$formula?",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",150,"^K",7,"^L",150,"^M",15,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"^;","~$javelin.core/formula?","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",15,"^1=",["^Z",[["~$c"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",150,"^L",150,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c"]]]]]],"~$propagate*",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",21,"^K",8,"^L",21,"^M",18,"^1C",true,"^Y",["^Z",["^[",["^Z",[["~$pri-map"]]]]]],"^1C",true,"^;","~$javelin.core/propagate*","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",18,"^1=",["^Z",[["^2K"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",21,"^L",21,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["^2K"]]]]]],"~$Cell",["^ ","^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",16,"^K",10,"^L",16,"^M",14,"~:declared",true],"~:num-fields",11,"^N",["^:",["^O","^P","^Q","^R","^S","^T","^U"]],"^;","~$javelin.core/Cell","^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",14,"~:type",true,"^K",10,"^J",104,"~:record",false,"^2N",true,"^L",104,"^V",["^:",["^O","^P","^Q","^R","^S","^T","^U"]]],"~$alts!",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",229,"^K",7,"^L",229,"^M",12,"^Y",["^Z",["^[",["^Z",[["~$&","~$cells"]]]]],"^1I","Given a number of cells, returns a formula cell whose value is a seq of\n  values from cells that changed in the last update. Note that multiple cells\n  may update atomically, which is why the formula's value is a seq.\n\n  Consider:\n\n      (def a (cell {:x 1 :y 2}))\n      (def x (cell= (:x a)))\n      (def y (cell= (:y a)))\n      (def z (alts! x y))\n\n  then,\n\n      (deref z) ;=> (1 2)\n\n      (swap! a assoc :x 42)\n      (deref z) ;=> (42)\n\n      (reset! a {:x 10 :y 20})\n      (deref z) ;=> (10 20)\n  ","^1J",["^ ","^1<",true,"^1@",0,"^1=",[["^Z",["^2T"]]],"^Y",["^Z",[["~$&","^2T"]]],"^1?",["^Z",[null]]]],"^;","~$javelin.core/alts!","^1<",true,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",12,"^1J",["^ ","^1<",true,"^1@",0,"^1=",[["^Z",["^2T"]]],"^Y",["^Z",[["~$&","^2T"]]],"^1?",["^Z",[null]]],"^1=",[["^Z",["^2T"]]],"^1>",null,"^1?",["^Z",[null]],"^K",1,"^J",229,"^L",229,"^1@",0,"^1A",true,"^Y",["^Z",[["~$&","^2T"]]],"^1I","Given a number of cells, returns a formula cell whose value is a seq of\n  values from cells that changed in the last update. Note that multiple cells\n  may update atomically, which is why the formula's value is a seq.\n\n  Consider:\n\n      (def a (cell {:x 1 :y 2}))\n      (def x (cell= (:x a)))\n      (def y (cell= (:y a)))\n      (def z (alts! x y))\n\n  then,\n\n      (deref z) ;=> (1 2)\n\n      (swap! a assoc :x 42)\n      (deref z) ;=> (42)\n\n      (reset! a {:x 10 :y 20})\n      (deref z) ;=> (10 20)\n  "],"~$dosync*",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",213,"^K",7,"^L",213,"^M",14,"^Y",["^Z",["^[",["^Z",[["^16"]]]]],"^1I","Calls the thunk with no arguments within a transaction. Propagation of\n  updates to formula cells is deferred until the transaction is complete.\n  Input cells *will* update during the transaction. Transactions may be\n  nested.\n\n  See also: the javelin.core/dosync macro."],"^;","~$javelin.core/dosync*","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",14,"^1=",["^Z",[["^16"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",213,"^L",213,"^1@",1,"^1A",true,"^Y",["^Z",["^[",["^Z",[["^16"]]]]],"^1I","Calls the thunk with no arguments within a transaction. Propagation of\n  updates to formula cells is deferred until the transaction is complete.\n  Input cells *will* update during the transaction. Transactions may be\n  nested.\n\n  See also: the javelin.core/dosync macro."],"~$cell-map",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",258,"^K",7,"^L",258,"^M",15,"^Y",["^Z",["^[",["^Z",[["~$f","~$c"]]]]],"^1I","Given a function f and a cell c that contains a seqable collection of items,\n  returns a seq of formula cells such that the ith formula cell is equivalent\n  to (cell= (f (nth c i)))."],"^;","~$javelin.core/cell-map","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",15,"^1=",["^Z",[["~$f","~$c"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",258,"^L",258,"^1@",2,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$f","~$c"]]]]],"^1I","Given a function f and a cell c that contains a seqable collection of items,\n  returns a seq of formula cells such that the ith formula cell is equivalent\n  to (cell= (f (nth c i)))."],"~$safe-nth",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",42,"^K",8,"^L",42,"^M",16,"^1C",true,"^Y",["^Z",["^[",["^Z",[["~$c","~$i"]]]]]],"^1C",true,"^;","~$javelin.core/safe-nth","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",16,"^1=",["^Z",[["~$c","~$i"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",42,"^L",42,"^1@",2,"^1A",true,"^Y",["^Z",["^[",["^Z",[["~$c","~$i"]]]]]],"~$formula",["^ ","^G",null,"^H",["^ ","^I","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/javelin/core.cljs","^J",177,"^K",7,"^L",177,"^M",14,"^Y",["^Z",["^[",["^Z",[["~$f"],["~$f","^20"]]]]],"^1I","Returns a function that returns a formula cell with f as its formula, and\n  if updatefn is provided the returned cell is a lens.\n\n  See also: the javelin.core/cell= macro.\n\n      (def x (cell 100))\n      (def y (cell 200))\n\n      (def z1 (cell= (+ x y)))\n      (def z2 ((formula +) x y))\n\n  The formula cells z1 and z2 are equivalent.","^1J",["^ ","^1<",false,"^1@",2,"^1=",["^Z",[["~$f"],["~$f","^20"]]],"^Y",["^Z",[["~$f"],["~$f","^20"]]],"^1?",["^Z",[null,null]]]],"^;","~$javelin.core/formula","^1<",false,"^I","target/cljsbuild/public/js/out/javelin/core.cljs","^M",14,"^1J",["^ ","^1<",false,"^1@",2,"^1=",["^Z",[["~$f"],["~$f","^20"]]],"^Y",["^Z",[["~$f"],["~$f","^20"]]],"^1?",["^Z",[null,null]]],"^1=",["^Z",[["~$f"],["~$f","^20"]]],"^1>",null,"^1?",["^Z",[null,null]],"^K",1,"^J",177,"^L",177,"^1@",2,"^1A",true,"^Y",["^Z",[["~$f"],["~$f","^20"]]],"^1I","Returns a function that returns a formula cell with f as its formula, and\n  if updatefn is provided the returned cell is a lens.\n\n  See also: the javelin.core/cell= macro.\n\n      (def x (cell 100))\n      (def y (cell 200))\n\n      (def z1 (cell= (+ x y)))\n      (def z2 ((formula +) x y))\n\n  The formula cells z1 and z2 are equivalent."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^<","^<"],"~:cljs.analyzer/constants",["^ ","~:seen",["^:",["~:javelin.core/none","^H","~:else","^17","^10","^15","^1:","^14","^19","^12","^18","^16","^11","^13"]],"~:order",["^37","^10","^11","^12","^13","^14","^15","^16","^17","^18","^19","^1:","^36","^H"]],"^1I",null]