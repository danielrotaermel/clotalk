["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check.properties","~:imports",null,"~:requires",["^ ","~$gen","~$clojure.test.check.generators","^:","^:"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$apply-gen",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","~:line",13,"~:column",8,"~:end-line",13,"~:end-column",17,"~:private",true,"~:arglists",["~#list",["~$quote",["^H",[["~$function"]]]]]],"^F",true,"^5","~$clojure.test.check.properties/apply-gen","~:variadic",false,"^A","target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","^E",17,"~:method-params",["^H",[["^J"]]],"~:protocol-impl",null,"~:arglists-meta",["^H",[null,null]],"^C",1,"^B",13,"^D",13,"~:max-fixed-arity",1,"~:fn-var",true,"^G",["^H",["^I",["^H",[["^J"]]]]]],"~$for-all*",["^ ","^?",null,"^@",["^ ","^A","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","^B",23,"^C",7,"^D",23,"^E",15,"^G",["^H",["^I",["^H",[["~$args","^J"]]]]],"~:doc","Creates a property (properties are also generators). A property\n  is a generator that generates the result of applying the function\n  under test with the realized arguments. Once realized, the arguments\n  will be applied to `function` with `apply`.\n\n  Example:\n\n  (for-all* [gen/int gen/int] (fn [a b] (>= (+ a b) a)))\n  "],"^5","~$clojure.test.check.properties/for-all*","^L",false,"^A","target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","^E",15,"^M",["^H",[["^S","^J"]]],"^N",null,"^O",["^H",[null,null]],"^C",1,"^B",23,"^D",23,"^P",2,"^Q",true,"^G",["^H",["^I",["^H",[["^S","^J"]]]]],"^T","Creates a property (properties are also generators). A property\n  is a generator that generates the result of applying the function\n  under test with the realized arguments. Once realized, the arguments\n  will be applied to `function` with `apply`.\n\n  Example:\n\n  (for-all* [gen/int gen/int] (fn [a b] (>= (+ a b) a)))\n  "],"~$binding-vars",["^ ","^?",null,"^@",["^ ","^A","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","^B",38,"^C",8,"^D",38,"^E",20,"^F",true,"^G",["^H",["^I",["^H",[["~$bindings"]]]]]],"^F",true,"^5","~$clojure.test.check.properties/binding-vars","^L",false,"^A","target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","^E",20,"^M",["^H",[["^W"]]],"^N",null,"^O",["^H",[null,null]],"^C",1,"^B",38,"^D",38,"^P",1,"^Q",true,"^G",["^H",["^I",["^H",[["^W"]]]]]],"~$binding-gens",["^ ","^?",null,"^@",["^ ","^A","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","^B",42,"^C",8,"^D",42,"^E",20,"^F",true,"^G",["^H",["^I",["^H",[["^W"]]]]]],"^F",true,"^5","~$clojure.test.check.properties/binding-gens","^L",false,"^A","target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","^E",20,"^M",["^H",[["^W"]]],"^N",null,"^O",["^H",[null,null]],"^C",1,"^B",42,"^D",42,"^P",1,"^Q",true,"^G",["^H",["^I",["^H",[["^W"]]]]]],"~$for-all",["^ ","^?",null,"^@",["^ ","^A","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","^B",46,"^C",11,"^D",46,"^E",18,"~:macro",true,"^G",["^H",["^I",["^H",[["^W","~$&","~$body"]]]]],"^T","Macro sugar for `for-all*`. `for-all` lets you name the parameter\n  and use them in expression, without wrapping them in a lambda. Like\n  `for-all*`, it returns a property.\n\n  Examples\n\n  (for-all [a gen/int\n            b gen/int]\n    (>= (+ a b) a))\n  ","~:top-fn",["^ ","^L",true,"^P",3,"^M",[["^H",["~$&form","~$&env","^W","^11"]]],"^G",["^H",[["^13","^14","^W","~$&","^11"]]],"^O",["^H",[null]]]],"^5","~$clojure.test.check.properties/for-all","^L",true,"^A","target/cljsbuild/public/js/out/clojure/test/check/properties.cljc","^E",18,"^12",["^ ","^L",true,"^P",3,"^M",[["^H",["^13","^14","^W","^11"]]],"^G",["^H",[["^13","^14","^W","~$&","^11"]]],"^O",["^H",[null]]],"^M",[["^H",["^13","^14","^W","^11"]]],"^N",null,"^O",["^H",[null]],"^C",1,"^B",46,"^10",true,"^D",46,"^P",3,"^Q",false,"^G",["^H",[["^13","^14","^W","~$&","^11"]]],"^T","Macro sugar for `for-all*`. `for-all` lets you name the parameter\n  and use them in expression, without wrapping them in a lambda. Like\n  `for-all*`, it returns a property.\n\n  Examples\n\n  (for-all [a gen/int\n            b gen/int]\n    (>= (+ a b) a))\n  "]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:args","^U","~:function","~:result","~$cljs.core/fn"]],"~:order",["^1<","^1;","^1:","^U","^1="]],"^T",null]