["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:imports",null,"~:requires",["^ ","~$gen","~$clojure.test.check.generators","^:","^:","~$ct","~$clojure.test.check.clojure-test","^<","^<","~$random","~$clojure.test.check.random","^>","^>","~$rose","~$clojure.test.check.rose-tree","^@","^@","~$clojure.test.check.impl","^A"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$exception-like?","^A","~$get-current-time-millis","^A"],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check.cljc","~:line",79,"~:column",8,"~:end-line",79,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^Q",[["~$rose-tree"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"^O",true,"^5","~$clojure.test.check/shrink-loop","~:variadic",false,"^J","target/cljsbuild/public/js/out/clojure/test/check.cljc","^N",19,"~:method-params",["^Q",[["^S"]]],"~:protocol-impl",null,"~:arglists-meta",["^Q",[null,null]],"^L",1,"^K",79,"^M",79,"~:max-fixed-arity",1,"~:fn-var",true,"^P",["^Q",["^R",["^Q",[["^S"]]]]],"^T","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"~$failure",["^ ","^H",null,"^I",["^ ","^J","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check.cljc","^K",112,"^L",8,"^M",112,"^N",15,"^O",true,"^P",["^Q",["^R",["^Q",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed"]]]]]],"^O",true,"^5","~$clojure.test.check/failure","^V",false,"^J","target/cljsbuild/public/js/out/clojure/test/check.cljc","^N",15,"^W",["^Q",[["^11","^12","^13","^14","^15"]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",112,"^M",112,"^Z",5,"^[",true,"^P",["^Q",["^R",["^Q",[["^11","^12","^13","^14","^15"]]]]]],"~$make-rng",["^ ","^H",null,"^I",["^ ","^J","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check.cljc","^K",20,"^L",8,"^M",20,"^N",16,"^O",true,"^P",["^Q",["^R",["^Q",[["^15"]]]]]],"^O",true,"^5","~$clojure.test.check/make-rng","^V",false,"^J","target/cljsbuild/public/js/out/clojure/test/check.cljc","^N",16,"^W",["^Q",[["^15"]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",20,"^M",20,"^Z",1,"^[",true,"^P",["^Q",["^R",["^Q",[["^15"]]]]]],"~$complete",["^ ","^H",null,"^I",["^ ","^J","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check.cljc","^K",27,"^L",8,"^M",27,"^N",16,"^O",true,"^P",["^Q",["^R",["^Q",[["^11","~$num-trials","^15"]]]]]],"^O",true,"^5","~$clojure.test.check/complete","^V",false,"^J","target/cljsbuild/public/js/out/clojure/test/check.cljc","^N",16,"^W",["^Q",[["^11","^1:","^15"]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",27,"^M",27,"^Z",3,"^[",true,"^P",["^Q",["^R",["^Q",[["^11","^1:","^15"]]]]]],"~$not-falsey-or-exception?",["^ ","^H",null,"^I",["^ ","^J","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check.cljc","^K",32,"^L",8,"^M",32,"^N",32,"^O",true,"^P",["^Q",["^R",["^Q",[["~$value"]]]]],"^T","True if the value is not falsy or an exception"],"^O",true,"^5","~$clojure.test.check/not-falsey-or-exception?","^V",false,"^J","target/cljsbuild/public/js/out/clojure/test/check.cljc","^N",32,"^W",["^Q",[["^1="]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",32,"^M",32,"^Z",1,"^[",true,"^P",["^Q",["^R",["^Q",[["^1="]]]]],"^T","True if the value is not falsy or an exception"],"~$quick-check",["^ ","^H",null,"^I",["^ ","^J","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check.cljc","^K",37,"^L",7,"^M",37,"^N",18,"^P",["^Q",["^R",["^Q",[["~$num-tests","^11","~$&",["^ ","~:keys",["^15","~$max-size"],"~:or",["^ ","^1B",200]]]]]]],"^T","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  ","~:top-fn",["^ ","^V",true,"^Z",2,"^W",[["^Q",["^1@","^11",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^P",["^Q",[["^1@","^11","~$&",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^Y",["^Q",[null]]]],"^5","~$clojure.test.check/quick-check","^V",true,"^J","target/cljsbuild/public/js/out/clojure/test/check.cljc","^N",18,"^1D",["^ ","^V",true,"^Z",2,"^W",[["^Q",["^1@","^11",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^P",["^Q",[["^1@","^11","~$&",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^Y",["^Q",[null]]],"^W",[["^Q",["^1@","^11",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^X",null,"^Y",["^Q",[null]],"^L",1,"^K",37,"^M",37,"^Z",2,"^[",true,"^P",["^Q",[["^1@","^11","~$&",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^T","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  "],"~$smallest-shrink",["^ ","^H",null,"^I",["^ ","^J","/Users/ezekills/Git/clotalk/target/cljsbuild/public/js/out/clojure/test/check.cljc","^K",72,"^L",8,"^M",72,"^N",23,"^O",true,"^P",["^Q",["^R",["^Q",[["~$total-nodes-visited","~$depth","~$smallest"]]]]]],"^O",true,"^5","~$clojure.test.check/smallest-shrink","^V",false,"^J","target/cljsbuild/public/js/out/clojure/test/check.cljc","^N",23,"^W",["^Q",[["^1G","^1H","^1I"]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",72,"^M",72,"^Z",3,"^[",true,"^P",["^Q",["^R",["^Q",[["^1G","^1H","^1I"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:args","~:shrunk","~:total-nodes-visited","~:num-tests","~:max-size","~:seed","~:fail","~:result","~:smallest","~:failing-size","~:depth"]],"~:order",["^1V","^1R","^1T","^1S","^1O","^1Q","^1Y","^1W","^1X","^1U","^1P"]],"^T",null]